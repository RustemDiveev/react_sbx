<!DOCTYPE HTML>
<html>

    <head>
        <meta charset="utf-8">
        <link rel="stylesheet" href="./css/common.css">
    </head>

    <body>

        <button><a href="../start_here.html">К содержанию</a></button> 
        <h1>Логические операторы</h1>
        <ul>
            <li>|| (ИЛИ)</li>
            <li>&& (И)</li>
            <li>! (НЕ)</li>
        </ul>
        <p>
            Хоть и называются логическими, но могут применяться к значениям любого типа и возвращают значения любого типа.
        </p>

        <h2>|| (ИЛИ)</h2>
        <p>Если хотя бы один аргумент true - то возвращает true, иначе false. Но в JS не совсем так.</p>
        <p>Если значение не логического типа, то приводится к нему в рамках вычислений. Например, 1 - true, 0 - false</p>

        <h3>Короткий цикл вычислений</h3>
        <p>
            Для экономии ресурсов, если вычисляются несколько первых ИЛИ подряд, и натыкаемся на true, то вычисление приостанавливается.
            Для И аналогично, но для false.
        </p>
<code>
var x, y;
true || (x = 1);
false || (y = 1);
alert(x); // undefined
alert(y); // 1
</code>
        <p>
            Оператор ИЛИ вычисляет ровно столько значений, сколько необходимо - до первого true. При этом, возвращает то значение, 
            на котором остановилось вычисление. Значение не преобразовывается к логическому типу. Если все значения false, то вернет последнее из них.
        </p>
<code>
var a = 0 || 1; //1
var b = undefined || 0; //0
var c = undefined || 0 || "" || "Дарова, пацаны!"; //Дарова, пацаны
</code>

        <h2>&& (И)</h2>
        <p>
            Принцип тот же, что и с ИЛИ, только для false.
        </p>
        <p>
            Если левый аргумент false - оператор возвращает его и заканчивает вычисления. Иначе - вычисляет и возвращает правый аргумент.
        </p>
<code>
var a = 1 && 0; //0
var b = 1 && 5; //5
var c = 1 && 2 && null & 3; //null
var d = 0 && null; //0
</code>

        <h3>Приоритет у && больше, чем у ||</h3>
<code>
var x = 5 || 1 && 0; // вначале 1 && 0 = 0, потом 5 || 0 = 5
</code>

        <h3>Не используйте && вместо if</h3>
<code>
(x > 0) && alert("Больше"); // Правое выполнится в том случае, если до него дойдут вычисления 

// Аналог
if (x > 0) {
    alert("Больше");
}

// но if лучше читается и воспринимается
</code>

        <h2>! (НЕ)</h2>
        <ol>
            <li>Сначала приводит аргумент к логическому типу true/false</li>
            <li>Потом возвращает противоположное значение.</li>
        </ol>

        <p>Двойное НЕ используют для преобразования к логическому типу.</p>
<code>
!true // false 
!0 // true 
!!"string" // true 
!!null // false
</code>

        <h1>Задачи</h1>

<code>
// 1

alert(null || 2 || undefined);
// выведет 2, тк оно - true, на нем и остановится

// 2 

alert(alert(1) || 2 || alert(3));
// alert возвращает undefined 
// Выведет 1, потом 2 

// 3 

alert(1 && null && 2); 
// выведет null 

// 4 

alert(alert(1) && alert(2));
// выведет 1, а потом undefined

// 5 

alert(null || 2 && 3 || 4);
// выведет 3, вначале посчитает 2 && 3 = 3, потом null || 3 = 3

// 6 

// Написать условие if для проверки того, что age находится между 14 и 90 включительно: 
// Вот это неправильно - так не делать 
if (14 <= age <= 90) {
    alert("good");
}

// Но автор подразумевает, что я сделаю так 
if ((age >= 14) && (age <= 90)) {
    alert("good");
}

// 7 

// Написать условие if для проверки, что age не находится между 14 и 90 включительно: 
// два варианта: с НЕ и без НЕ 
// Вот это неправильно - так не делать 
if (!(14 <= age <= 90)) {
    alert("good");
}

if (!((14 <= age) && (age <= 90))) {
    alert("good");
}

if ((age < 14) || (age > 90)) {
    alert("good");
}

// 8 
// Какие if верны, и что будет результатом внутри if 
if (-1 || 0) alert("first"); // true, -1
if (-1 && 0) alert("second"); // false, 0
if (null || -1 && 1) alert("third"); // true, 1
</code>

    </body>

</html>