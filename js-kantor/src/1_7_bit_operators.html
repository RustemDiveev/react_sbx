<!DOCTYPE HTML>
<html>

    <head>
        <meta charset="utf-8">
    </head>

    <body>
        <script src="./js/1_7_script1.js"></script>

        <button><a href="../start_here.html">К содержанию</a></button> 
        <h1>Побитовые операторы</h1>
        <p>
            Эти операторы интерпретируют операнды как последовательность из 32 битов нулей и единиц и производят операции, используя двоичное представление числа.
            <br>
            Возвращают новую 32-битовую последовательность (число) в качестве результата.
        </p>

        <h2>Формат 32-битного целого числа со знаком</h2>
        <p>
            Двоичное представление, с которым работают битовые операторы - 32-битное целое со знаком, старшим битом слева и дополнением до двойки.
        </p>
        <ul>
            <li><strong>Двоичная система;</strong></li>
            <li><strong>Старший бит слева</strong> - порядок записи цифр (от большего разряда к меньшему). Если больший разряд отсутствует - то ноль;</li>
            <li>
                <strong>Дополнение до двойки</strong> - способ поддержки отрицательных чисел.
                <p>
                    Двоичный вид числа, обратный данному (например, из 5 в -5) получается путем обращения всех битов и прибавлением 1.
                </p>
                <code>
                    Число: 314
                    <br>
                    256 + 32 + 16 + 8 + 2
                    <br>
                    0000 0000 0000 0000 0000 0001 0011 1010 // число 314   
                    <br>
                    1111 1111 1111 1111 1111 1110 1100 0101 // обращаем биты 
                    <br>
                    1111 1111 1111 1111 1111 1110 1100 0110 // добавляем 1 
                    <br>
                    // проверим, верно ли обратное 
                    <br>
                    1111 1111 1111 1111 1111 1110 1100 0110 // число -314 
                    <br>
                    0000 0000 0000 0000 0000 0001 0011 1001 // обращаем биты 
                    <br>
                    0000 0000 0000 0000 0000 0001 0011 1010 // добавляем 1 
                    <br>
                    // получили исходное число 
                </code>
                <p>
                    Если число начинается на 0, то оно положительное, 1 - отрицательное. Первый бит - знаковый бит.
                </p>
            </li>
        </ul>

        <h2>Список операторов</h2>
        <table>
            <tr>
                <th align="left">Оператор</th>
                <th align="left">Использование</th>
                <th align="left">Описание</th>
            </tr>
            <tr>
                <td>Побитовое И (AND)</td>
                <td>a & b</td>
                <td>1 - если биты одной позиции равны 1, иначе 0</td>
            </tr>
            <tr>
                <td>Побитовое ИЛИ (OR)</td>
                <td>a | b</td>
                <td>0 - если биты одной позиции равны 0, иначе 1</td>
            </tr>
            <tr>
                <td>Побитовое исключаещее ИЛИ (XOR)</td>
                <td>a ^ b</td>
                <td>1 - если только один бит 1, а другой 0, иначе 0</td>
            </tr>
            <tr>
                <td>Побитовое НЕ (NOT)</td>
                <td>~a</td>
                <td>1 - если только один бит 1, а другой 0, иначе 0</td>
            </tr>
            <tr>
                <td>Левый сдвиг</td>
                <td>a << b</td>
                <td>Сдвигает a на b битов влево, добавляя справа нули</td>
            </tr>
            <tr>
                <td>Правый сдвиг</td>
                <td>a >> b</td>
                <td>Сдвигает a на b битов вправо, отбрасывая сдвигаемые биты, переносит знак</td>
            </tr>
            <tr>
                <td>Правый сдвиг с заполнением нулями</td>
                <td>a >>> b</td>
                <td>Сдвигает a на b битов вправо, отбрасывая сдвигаемые биты и добавляя нули слева. Знаковый бит равен 0, поэтому, результат всегда положительный.</td>
            </tr>
        </table>

        <p>
            Есть такие хэлперы:
            <ul>
                <li><code>parseInt(string, 2); // перевод в число строки с двоичной записью</code></li>
                <li><code>n.toString(2); // получение двоичной записи из числа</code></li>
            </ul>

            <p>
                Для демонстрации, написал функцию perform_bit_operation, логирующую все в консоль.
                Мне лень писать интерактив, поэтому ниже будут просто примеры вызовов, чтобы потом все вспомнить.
            </p>
            <p>
                Для дробных чисел при выполнении битовой операции дробная часть отбрасывается.
            </p>
            <ul>
                <li>perform_bit_operation(8, 4, "&");</li>
                <li>perform_bit_operation(8.32, 4, "&");</li>
                <li>perform_bit_operation(8, 4, "|");</li>
                <li>perform_bit_operation(9, 5, "^");</li>
                <li>perform_bit_operation(1, undefined, "~");</li>
                <li>perform_bit_operation(2242, 3, "<<");</li>
                <li>perform_bit_operation(-2242, 3, ">>");</li>
                <li>perform_bit_operation(-2242, 3, ">>>");</li>
            </ul>
            <p>
                Я не понял до конца, как преобразовать представление в битах отрицательного числа в его значение.
            </p>
        </p>

        <h2>Исключающее ИЛИ в шифровании</h2>
        <p>
            a ^ b ^ b == a;
        </p>
        <p>
            Операция полностью обратима. 
            Если у двух сторон есть ключ b, то можно шифрануть a на одной стороне, потом раз применить тот же ключ на другой стороне и будет исходная строка.
        </p>
        <code>
            perform_bit_operation(perform_bit_operation(123142, 321, "^"), 321, "^");
        </code>

        <h2>Приоритет</h2>
        <p>
            Побитовые операторы ^, &, | выполняются после сравнений ==. 
            <br>
            Например, в a == b ^ 0: будет выполнено вначале a == b, а затем ^ 0.
            <br>
            Нужно: a == (b ^ 0)
        </p>

        <h2>Округление</h2>
        <p>
            Битовые операции отбрасывают десятичную часть, т.е можно использовать для округления.
        </p>
        <code>
            ~~12.345 //12
            <br>
            12.345 ^ 0 //12
        </code>

        <h2>Проверка на -1</h2>
        <code>
            -n = ~n + 1;
            <br>
            ~n = -(n + 1);
            <br>
            ~n == 0, только если n == -1
        </code>

        <p>
            Проверка на -1 пригождается при поиске символа в строке:
        </p>
        <code>
            var str = "DIVEEV_TEST";
            <br>
            if (~str.indexOf("TEST")) {
            <br>
                alert("Found");
            <br>
            }
        </code>

        <h2>Задача 1</h2>
        <code>
            alert(123 ^ 0); //123 - применение 0 ^ 0 = 0, 1 ^ 0 = 1, т.е будет тот же самый бит
            <br>
            alert(0 ^ 123); //123 - то же самое, порядок операндов не имеет значения 
            <br>
            alert(~~123); //123 - двойное отрицание дает тот же самый результат, 0 -> 1 -> 0
        </code>

        <h2>Задача 2</h2>
        <p>
            Написать функцию isInteger(num), возвращающая true, если num - целое число.
        </p>
        <code>
            num - (num ^ 0) === 0
        </code>

        <h2>Задача 3</h2>
        <p>
            Симметричны ли операции: ^, |, &? 
            Да, порядок операндов имеет значение.
            a ^ b == b ^ a 
            a & b == b & a 
            a | b == b | a 
        </p>

        <h2>Задача 4</h2>
        <p>Почему результат равный<p>
        <code>
            perform_bit_operation(12345678912345, 0, "^");
            <br>
            1_7_script1.js:14 Выполняется операция: 12345678912345 ^ 0
            <br>
            1_7_script1.js:16 Первый операнд в двоичном виде: 10110011101001110011110011100101101101011001
            <br>
            1_7_script1.js:47 Результат в двоичном виде: 1110011110011100101101101011001
            <br>
            1_7_script1.js:48 Итоговый результат: 1942903641
        </code>

    </body>

</html>